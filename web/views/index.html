<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QRL Trading Bot - Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Monaco', 'Courier New', monospace;
      background: #0a0e27;
      color: #00ff41;
      padding: 20px;
      line-height: 1.6;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #00ff41;
      text-shadow: 0 0 10px #00ff41;
    }
    
    .nav-links {
      text-align: center;
      margin-bottom: 20px;
    }
    
    .nav-links a {
      color: #00d4ff;
      text-decoration: none;
      margin: 0 15px;
      padding: 8px 16px;
      border: 1px solid #00d4ff;
      border-radius: 4px;
      transition: all 0.3s;
    }
    
    .nav-links a:hover {
      background: #00d4ff;
      color: #0a0e27;
    }
    
    .chart-container {
      background: #1a1f3a;
      border: 2px solid #00ff41;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
    }
    
    .chart-container h2 {
      color: #00d4ff;
      margin-bottom: 15px;
      font-size: 1.2em;
      border-bottom: 1px solid #00ff41;
      padding-bottom: 10px;
    }
    
    #priceChart {
      max-height: 400px;
    }
    
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .card {
      background: #1a1f3a;
      border: 2px solid #00ff41;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
    }
    
    .card h2 {
      color: #00d4ff;
      margin-bottom: 15px;
      font-size: 1.2em;
      border-bottom: 1px solid #00ff41;
      padding-bottom: 10px;
    }
    
    .data-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid #2a3f5f;
    }
    
    .data-row:last-child {
      border-bottom: none;
    }
    
    .label {
      color: #00d4ff;
    }
    
    .value {
      color: #00ff41;
      font-weight: bold;
    }
    
    .positive {
      color: #00ff41;
    }
    
    .negative {
      color: #ff4444;
    }
    
    .status-connected {
      color: #00ff41;
    }
    
    .status-disconnected {
      color: #ff4444;
    }
    
    .status-warning {
      color: #ffaa00;
    }
    
    .progress-bar {
      width: 100%;
      height: 24px;
      background: #0a0e27;
      border: 1px solid #00ff41;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 10px;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #00ff41, #00d4ff);
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #0a0e27;
      font-weight: bold;
      font-size: 0.9em;
    }
    
    .footer {
      text-align: center;
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid #00ff41;
      color: #00d4ff;
      font-size: 0.9em;
    }
    
    .loading {
      text-align: center;
      color: #00d4ff;
      font-size: 1.1em;
      padding: 20px;
    }
    
    .timeframe-selector {
      background: rgba(0, 255, 65, 0.05);
      border: 1px solid #00ff41;
      border-radius: 8px;
      padding: 15px;
      margin: 20px 0;
      text-align: center;
    }
    
    .timeframe-btn {
      background: #001a0a;
      border: 1px solid #00ff41;
      color: #00ff41;
      padding: 8px 16px;
      margin: 0 5px;
      cursor: pointer;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      transition: all 0.3s;
    }
    
    .timeframe-btn:hover {
      background: rgba(0, 255, 65, 0.2);
      box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
    }
    
    .timeframe-btn.active {
      background: #00ff41;
      color: #001a0a;
      font-weight: bold;
    }
    
    .indicators-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üìä QRL Trading Bot - Dashboard</h1>
    
    <div class="nav-links">
      <a href="/">Dashboard</a>
      <a href="/history">Trade History</a>
      <a href="/health" target="_blank">Health Check</a>
    </div>
    
    <!-- Timeframe Selector -->
    <div class="timeframe-selector">
      <label style="color: #0f0; margin-right: 10px;">‚è±Ô∏è Timeframe:</label>
      <button class="timeframe-btn active" data-timeframe="1m">1m</button>
      <button class="timeframe-btn" data-timeframe="5m">5m</button>
      <button class="timeframe-btn" data-timeframe="15m">15m</button>
      <button class="timeframe-btn" data-timeframe="30m">30m</button>
      <button class="timeframe-btn" data-timeframe="1h">1h</button>
      <button class="timeframe-btn" data-timeframe="4h">4h</button>
      <button class="timeframe-btn" data-timeframe="1d">1d</button>
    </div>
    
    <!-- Price Chart -->
    <div class="chart-container">
      <h2>üìà Price & Moving Averages (Redis-Cached Data)</h2>
      <canvas id="priceChart"></canvas>
      <div class="loading" id="chartLoading">Loading chart data from Redis...</div>
    </div>
    
    <!-- Volume Chart -->
    <div class="chart-container">
      <h2>üìä Volume</h2>
      <canvas id="volumeChart"></canvas>
    </div>
    
    <!-- Indicators Charts -->
    <div class="indicators-grid">
      <div class="chart-container">
        <h2>üìâ Williams %R</h2>
        <canvas id="williamsChart"></canvas>
      </div>
      
      <div class="chart-container">
        <h2>üìä MACD</h2>
        <canvas id="macdChart"></canvas>
      </div>
      
      <div class="chart-container">
        <h2>üìà RSI</h2>
        <canvas id="rsiChart"></canvas>
      </div>
    </div>
    
    <div class="grid">
      <!-- Market Data Card -->
      <div class="card">
        <h2>üìà Market Data</h2>
        <div id="market-data">
          <div class="loading">Loading...</div>
        </div>
      </div>
      
      <!-- Position Card -->
      <div class="card">
        <h2>üíº Position</h2>
        <div id="position-data">
          <div class="loading">Loading...</div>
        </div>
      </div>
      
      <!-- Strategy Card -->
      <div class="card">
        <h2>üìä Strategy Status</h2>
        <div id="strategy-data">
          <div class="loading">Loading...</div>
        </div>
      </div>
      
      <!-- System Health Card -->
      <div class="card">
        <h2>üîß System Status</h2>
        <div id="system-data">
          <div class="loading">Loading...</div>
        </div>
      </div>
    </div>
    
    <div class="footer">
      <p>Auto-refresh every 60 seconds | Data cached in Redis | UTC Time: <span id="current-time"></span></p>
      <p>QRL Trading Bot v2.0 - Production Ready</p>
    </div>
  </div>

  <script>
    let priceChart = null;
    let volumeChart = null;
    let williamsChart = null;
    let macdChart = null;
    let rsiChart = null;
    let currentTimeframe = '1m';
    
    // Initialize all charts
    function initializeCharts() {
      // Price Chart
      const priceCtx = document.getElementById('priceChart').getContext('2d');
      priceChart = new Chart(priceCtx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Price (QRL/USDT)',
              data: [],
              borderColor: '#00ff41',
              backgroundColor: 'rgba(0, 255, 65, 0.1)',
              borderWidth: 2,
              tension: 0.4,
              fill: true,
              yAxisID: 'y'
            },
            {
              label: 'MA 20',
              data: [],
              borderColor: '#ffaa00',
              borderWidth: 1.5,
              borderDash: [3, 3],
              tension: 0.4,
              fill: false,
              yAxisID: 'y'
            },
            {
              label: 'MA 60',
              data: [],
              borderColor: '#ff6600',
              borderWidth: 1.5,
              borderDash: [3, 3],
              tension: 0.4,
              fill: false,
              yAxisID: 'y'
            },
            {
              label: 'EMA 20',
              data: [],
              borderColor: '#00d4ff',
              borderWidth: 2,
              borderDash: [5, 5],
              tension: 0.4,
              fill: false,
              yAxisID: 'y'
            },
            {
              label: 'EMA 60',
              data: [],
              borderColor: '#ff00ff',
              borderWidth: 2,
              borderDash: [5, 5],
              tension: 0.4,
              fill: false,
              yAxisID: 'y'
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          aspectRatio: 2.5,
          plugins: {
            legend: {
              labels: {
                color: '#00ff41',
                font: {
                  family: "'Monaco', 'Courier New', monospace",
                  size: 11
                }
              }
            },
            tooltip: {
              backgroundColor: '#1a1f3a',
              titleColor: '#00d4ff',
              bodyColor: '#00ff41',
              borderColor: '#00ff41',
              borderWidth: 1
            }
          },
          scales: {
            x: {
              ticks: {
                color: '#00d4ff',
                maxRotation: 45,
                minRotation: 45
              },
              grid: {
                color: '#2a3f5f'
              }
            },
            y: {
              ticks: {
                color: '#00d4ff'
              },
              grid: {
                color: '#2a3f5f'
              }
            }
          }
        }
      });
      
      // Volume Chart
      const volumeCtx = document.getElementById('volumeChart').getContext('2d');
      volumeChart = new Chart(volumeCtx, {
        type: 'bar',
        data: {
          labels: [],
          datasets: [{
            label: 'Volume',
            data: [],
            backgroundColor: [],
            borderColor: [],
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          aspectRatio: 3,
          plugins: {
            legend: {
              labels: {
                color: '#00ff41',
                font: {
                  family: "'Monaco', 'Courier New', monospace",
                  size: 11
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: '#00d4ff',
                maxRotation: 45,
                minRotation: 45
              },
              grid: {
                color: '#2a3f5f'
              }
            },
            y: {
              ticks: {
                color: '#00d4ff'
              },
              grid: {
                color: '#2a3f5f'
              }
            }
          }
        }
      });
      
      // Williams %R Chart
      const williamsCtx = document.getElementById('williamsChart').getContext('2d');
      williamsChart = new Chart(williamsCtx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Williams %R',
            data: [],
            borderColor: '#ff6600',
            backgroundColor: 'rgba(255, 102, 0, 0.1)',
            borderWidth: 2,
            tension: 0.4,
            fill: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          aspectRatio: 2,
          plugins: {
            legend: {
              labels: {
                color: '#00ff41',
                font: {
                  family: "'Monaco', 'Courier New', monospace",
                  size: 11
                }
              }
            },
            annotation: {
              annotations: {
                line1: {
                  type: 'line',
                  yMin: -20,
                  yMax: -20,
                  borderColor: '#ff0000',
                  borderWidth: 1,
                  borderDash: [5, 5]
                },
                line2: {
                  type: 'line',
                  yMin: -80,
                  yMax: -80,
                  borderColor: '#00ff00',
                  borderWidth: 1,
                  borderDash: [5, 5]
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: '#00d4ff',
                maxRotation: 45,
                minRotation: 45
              },
              grid: {
                color: '#2a3f5f'
              }
            },
            y: {
              min: -100,
              max: 0,
              ticks: {
                color: '#00d4ff'
              },
              grid: {
                color: '#2a3f5f'
              }
            }
          }
        }
      });
      
      // MACD Chart
      const macdCtx = document.getElementById('macdChart').getContext('2d');
      macdChart = new Chart(macdCtx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'MACD',
              data: [],
              borderColor: '#00d4ff',
              borderWidth: 2,
              tension: 0.4,
              fill: false
            },
            {
              label: 'Signal',
              data: [],
              borderColor: '#ff00ff',
              borderWidth: 2,
              tension: 0.4,
              fill: false
            },
            {
              label: 'Histogram',
              data: [],
              type: 'bar',
              backgroundColor: 'rgba(0, 255, 65, 0.3)',
              borderColor: '#00ff41',
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          aspectRatio: 2,
          plugins: {
            legend: {
              labels: {
                color: '#00ff41',
                font: {
                  family: "'Monaco', 'Courier New', monospace",
                  size: 11
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: '#00d4ff',
                maxRotation: 45,
                minRotation: 45
              },
              grid: {
                color: '#2a3f5f'
              }
            },
            y: {
              ticks: {
                color: '#00d4ff'
              },
              grid: {
                color: '#2a3f5f'
              }
            }
          }
        }
      });
      
      // RSI Chart
      const rsiCtx = document.getElementById('rsiChart').getContext('2d');
      rsiChart = new Chart(rsiCtx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'RSI (14)',
            data: [],
            borderColor: '#00ff41',
            backgroundColor: 'rgba(0, 255, 65, 0.1)',
            borderWidth: 2,
            tension: 0.4,
            fill: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          aspectRatio: 2,
          plugins: {
            legend: {
              labels: {
                color: '#00ff41',
                font: {
                  family: "'Monaco', 'Courier New', monospace",
                  size: 11
                }
              }
            },
            annotation: {
              annotations: {
                line1: {
                  type: 'line',
                  yMin: 70,
                  yMax: 70,
                  borderColor: '#ff0000',
                  borderWidth: 1,
                  borderDash: [5, 5]
                },
                line2: {
                  type: 'line',
                  yMin: 30,
                  yMax: 30,
                  borderColor: '#00ff00',
                  borderWidth: 1,
                  borderDash: [5, 5]
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: '#00d4ff',
                maxRotation: 45,
                minRotation: 45
              },
              grid: {
                color: '#2a3f5f'
              }
            },
            y: {
              min: 0,
              max: 100,
              ticks: {
                color: '#00d4ff'
              },
              grid: {
                color: '#2a3f5f'
              }
            }
          }
        }
      });
    }
    
    // Update all charts with new data
    function updateCharts(chartData, indicatorsData) {
      if (!priceChart) {
        initializeCharts();
      }
      
      // Update Price Chart
      priceChart.data.labels = chartData.labels;
      priceChart.data.datasets[0].data = chartData.prices;
      priceChart.data.datasets[1].data = chartData.ma20;
      priceChart.data.datasets[2].data = chartData.ma60;
      priceChart.data.datasets[3].data = chartData.ema20;
      priceChart.data.datasets[4].data = chartData.ema60;
      priceChart.update();
      
      // Update Volume Chart
      volumeChart.data.labels = chartData.labels;
      volumeChart.data.datasets[0].data = chartData.volumes;
      volumeChart.data.datasets[0].backgroundColor = indicatorsData.volume_colors;
      volumeChart.data.datasets[0].borderColor = indicatorsData.volume_colors;
      volumeChart.update();
      
      // Update Williams %R Chart
      williamsChart.data.labels = indicatorsData.labels;
      williamsChart.data.datasets[0].data = indicatorsData.williams_r;
      williamsChart.update();
      
      // Update MACD Chart
      macdChart.data.labels = indicatorsData.labels;
      macdChart.data.datasets[0].data = indicatorsData.macd;
      macdChart.data.datasets[1].data = indicatorsData.macd_signal;
      macdChart.data.datasets[2].data = indicatorsData.macd_histogram;
      macdChart.update();
      
      // Update RSI Chart
      rsiChart.data.labels = indicatorsData.labels;
      rsiChart.data.datasets[0].data = indicatorsData.rsi;
      rsiChart.update();
      
      // Hide loading message
      document.getElementById('chartLoading').style.display = 'none';
    }
    
    // Fetch chart data from Redis-cached API
    async function fetchChartData() {
      try {
        const [chartResponse, indicatorsResponse] = await Promise.all([
          fetch(`/api/market/chart-data?timeframe=${currentTimeframe}`),
          fetch(`/api/market/indicators?timeframe=${currentTimeframe}`)
        ]);
        
        const chartData = await chartResponse.json();
        const indicatorsData = await indicatorsResponse.json();
        
        if (chartData.error || indicatorsData.error) {
          const errorMsg = chartData.message || indicatorsData.message || chartData.error || indicatorsData.error;
          console.log('Chart data unavailable:', errorMsg);
          document.getElementById('chartLoading').innerHTML = 
            `<span class="status-warning">${errorMsg}</span>`;
          return;
        }
        
        updateCharts(chartData, indicatorsData);
      } catch (error) {
        console.error('Error fetching chart data:', error);
        document.getElementById('chartLoading').innerHTML = 
          '<span class="negative">Failed to load charts</span>';
      }
    }
    
    // Timeframe selector event handlers
    document.addEventListener('DOMContentLoaded', () => {
      const timeframeBtns = document.querySelectorAll('.timeframe-btn');
      timeframeBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          // Update active state
          timeframeBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          
          // Update current timeframe and reload charts
          currentTimeframe = btn.dataset.timeframe;
          document.getElementById('chartLoading').style.display = 'block';
          fetchChartData();
        });
      });
    });
    
    // Fetch market data
    async function fetchMarketData() {
      try {
        const response = await fetch('/api/market');
        const data = await response.json();
        
        if (data.error) {
          // Show error message for market data
          document.getElementById('market-data').innerHTML = 
            `<div class="data-row"><span class="status-warning">${data.error}</span></div>`;
          // Don't return early - market data error doesn't affect balance display
        } else {
          const changeClass = data.change_24h >= 0 ? 'positive' : 'negative';
          const changeSymbol = data.change_24h >= 0 ? '+' : '';
          
          document.getElementById('market-data').innerHTML = `
            <div class="data-row">
              <span class="label">Symbol:</span>
              <span class="value">${data.symbol}</span>
            </div>
            <div class="data-row">
              <span class="label">Price:</span>
              <span class="value">$${data.price.toFixed(6)}</span>
            </div>
            <div class="data-row">
              <span class="label">24H Change:</span>
              <span class="value ${changeClass}">${changeSymbol}${data.change_24h.toFixed(2)}%</span>
            </div>
            <div class="data-row">
              <span class="label">EMA 20:</span>
              <span class="value">$${data.ema20.toFixed(6)}</span>
            </div>
            <div class="data-row">
              <span class="label">EMA 60:</span>
              <span class="value">$${data.ema60.toFixed(6)}</span>
            </div>
            <div class="data-row">
              <span class="label">Data Delay:</span>
              <span class="value status-connected">< 1s (Redis)</span>
            </div>
          `;
        }
      } catch (error) {
        console.error('Error fetching market data:', error);
        document.getElementById('market-data').innerHTML = 
          `<div class="data-row"><span class="negative">Failed to fetch market data</span></div>`;
      }
    }
    
    // Fetch position data
    async function fetchPositionData() {
      try {
        const statsResponse = await fetch('/api/statistics');
        const statsData = await statsResponse.json();
        
        // Fetch market data for balances
        const marketResponse = await fetch('/api/market');
        const marketData = await marketResponse.json();
        
        // Get values with fallbacks (don't block on errors)
        const utilization = statsData.position_utilization_pct || 0;
        const currentPosition = statsData.current_position || 0;
        const maxPosition = statsData.max_position_usdt || 0;
        const availableCapacity = statsData.available_capacity || 0;
        
        // Get balances from market data - ALWAYS display these
        const qrlBalance = marketData.balances?.qrl || 0;
        const usdtBalance = marketData.balances?.usdt || 0;
        
        document.getElementById('position-data').innerHTML = `
          <div class="data-row">
            <span class="label">QRL Holdings:</span>
            <span class="value positive">${qrlBalance.toFixed(4)} QRL</span>
          </div>
          <div class="data-row">
            <span class="label">USDT Balance:</span>
            <span class="value">${usdtBalance.toFixed(2)} USDT</span>
          </div>
          <div class="data-row">
            <span class="label">Current Position:</span>
            <span class="value">$${currentPosition.toFixed(2)}</span>
          </div>
          <div class="data-row">
            <span class="label">Max Position:</span>
            <span class="value">$${maxPosition.toFixed(2)}</span>
          </div>
          <div class="data-row">
            <span class="label">Available:</span>
            <span class="value">$${availableCapacity.toFixed(2)}</span>
          </div>
          <div class="data-row">
            <span class="label">Utilization:</span>
          </div>
          <div class="progress-bar">
            <div class="progress-fill" style="width: ${utilization}%">${utilization.toFixed(1)}%</div>
          </div>
        `;
      } catch (error) {
        console.error('Error fetching position data:', error);
        document.getElementById('position-data').innerHTML = 
          `<div class="data-row"><span class="negative">Error loading position data</span></div>`;
      }
    }
    
    // Fetch strategy status
    async function fetchStrategyData() {
      try {
        const marketResponse = await fetch('/api/market');
        const marketData = await marketResponse.json();
        
        const statsResponse = await fetch('/api/statistics');
        const statsData = await statsResponse.json();
        
        // Handle errors with specific messages
        if (marketData.error) {
          const errorMsg = marketData.error.includes('OHLCV') || marketData.error.includes('empty') 
            ? '‚ö†Ô∏è Waiting for market data... (Exchange may be initializing)'
            : marketData.error.includes('not initialized')
            ? '‚ö†Ô∏è System initializing... Please wait.'
            : `‚ö†Ô∏è ${marketData.error}`;
          
          document.getElementById('strategy-data').innerHTML = 
            `<div class="data-row"><span class="status-warning">${errorMsg}</span></div>`;
          return;
        }
        
        if (statsData.error) {
          document.getElementById('strategy-data').innerHTML = 
            `<div class="data-row"><span class="status-warning">‚ö†Ô∏è ${statsData.error}</span></div>`;
          return;
        }
        
        const buyThreshold = marketData.ema60 * 1.02;
        let statusText = '‚è∏Ô∏è Waiting';
        let detailText = 'Analyzing market conditions...';
        
        if (marketData.buy_signal) {
          statusText = '‚úÖ Ready to Buy';
          detailText = 'Conditions met - Ready to execute';
        } else if (marketData.price > buyThreshold) {
          if (marketData.ema20 < marketData.ema60) {
            detailText = 'Price too high & Momentum weak';
          } else {
            detailText = 'Price above threshold';
          }
        } else if (marketData.ema20 < marketData.ema60) {
          detailText = 'Weak momentum (EMA20 < EMA60)';
        }
        
        document.getElementById('strategy-data').innerHTML = `
          <div class="data-row">
            <span class="label">Status:</span>
            <span class="value ${marketData.buy_signal ? 'positive' : 'status-warning'}">${statusText}</span>
          </div>
          <div class="data-row">
            <span class="label">Details:</span>
            <span class="value">${detailText}</span>
          </div>
          <div class="data-row">
            <span class="label">Buy Condition:</span>
            <span class="value">Price ‚â§ $${buyThreshold.toFixed(6)}</span>
          </div>
          <div class="data-row">
            <span class="label">Last Trade:</span>
            <span class="value">${statsData.last_trade_time || 'None'}</span>
          </div>
        `;
      } catch (error) {
        console.error('Error fetching strategy data:', error);
      }
    }
    
    // Fetch system status
    async function fetchSystemData() {
      try {
        const healthResponse = await fetch('/health');
        const healthData = await healthResponse.json();
        
        const cacheResponse = await fetch('/api/cache/stats');
        const cacheData = await cacheResponse.json();
        
        // Health check status
        const healthStatus = healthData.status === 'healthy' ? '‚úÖ Healthy' : '‚ùå Unhealthy';
        const healthStatusClass = healthData.status === 'healthy' ? 'status-connected' : 'status-disconnected';
        
        // API connection status
        const apiStatus = healthData.status === 'healthy' ? '‚óè Connected' : '‚ö† Error';
        const apiStatusClass = healthData.status === 'healthy' ? 'status-connected' : 'status-disconnected';
        
        // Redis cache status
        const cacheStatus = cacheData.enabled ? 
          (cacheData.status === 'connected' ? '‚úÖ Connected' : '‚ö† Degraded') : 
          '‚ùå Disabled';
        const cacheStatusClass = cacheData.enabled && cacheData.status === 'connected' ? 
          'status-connected' : 'status-warning';
        
        document.getElementById('system-data').innerHTML = `
          <div class="data-row">
            <span class="label">Health Check:</span>
            <span class="value ${healthStatusClass}">${healthStatus}</span>
          </div>
          <div class="data-row">
            <span class="label">API Status:</span>
            <span class="value ${apiStatusClass}">${apiStatus}</span>
          </div>
          <div class="data-row">
            <span class="label">Redis Cache:</span>
            <span class="value ${cacheStatusClass}">${cacheStatus}</span>
          </div>
          <div class="data-row">
            <span class="label">Data Delay:</span>
            <span class="value status-connected">${cacheData.enabled ? '< 100ms' : '200-500ms'}</span>
          </div>
          <div class="data-row">
            <span class="label">Cache Keys:</span>
            <span class="value">${cacheData.cache_keys || 0}</span>
          </div>
        `;
      } catch (error) {
        console.error('Error fetching system data:', error);
      }
    }
    
    // Update current time
    function updateTime() {
      const now = new Date();
      document.getElementById('current-time').textContent = now.toISOString().replace('T', ' ').substring(0, 19);
    }
    
    // Refresh all data
    function refreshAllData() {
      fetchChartData();
      fetchMarketData();
      fetchPositionData();
      fetchStrategyData();
      fetchSystemData();
      updateTime();
    }
    
    // Initialize on load
    document.addEventListener('DOMContentLoaded', function() {
      initializeCharts();
      refreshAllData();
      
      // Auto-refresh every 60 seconds
      setInterval(refreshAllData, 60000);
      
      // Update time every second
      setInterval(updateTime, 1000);
    });
  </script>
</body>
</html>
